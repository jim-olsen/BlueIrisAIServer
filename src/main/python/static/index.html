<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BlueIris AI Server â€” Object Detection</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; }
    .row { margin-bottom: 12px; }
    label { display: inline-block; min-width: 120px; }
    input[type=number] { width: 100px; }
    #preview { max-width: 100%; height: auto; display:none; }
    #canvas { max-width: 100%; border: 1px solid #ccc; display:none; }
    #results { white-space: pre; background: #f8f8f8; padding: 10px; border: 1px solid #ddd; }
    .controls { display:flex; flex-wrap: wrap; gap: 12px; align-items:center; }
    .controls > div { display:flex; align-items:center; gap:8px; }
    button { padding: 6px 12px; }
  </style>
</head>
<body>
  <h2>Object Detection Tester</h2>
  <div class="row">
    <div class="controls">
      <div>
        <label for="model">Model:</label>
        <select id="model"></select>
      </div>
      <div>
        <label for="image">Image:</label>
        <input id="image" type="file" accept="image/png,image/jpeg" />
      </div>
      <div>
        <label for="min_confidence">conf:</label>
        <input id="min_confidence" type="number" step="0.01" min="0" max="1" value="0.25" />
      </div>
      <div>
        <label for="iou">iou:</label>
        <input id="iou" type="number" step="0.01" min="0" max="1" value="0.45" />
      </div>
      <div>
        <label for="max_det">max_det:</label>
        <input id="max_det" type="number" step="1" min="1" value="100" />
      </div>
      <div>
        <button id="runBtn">Run detection</button>
      </div>
    </div>
  </div>

  <div class="row">
    <img id="preview" alt="preview" />
    <canvas id="canvas"></canvas>
  </div>

  <div class="row">
    <h3>Response</h3>
    <div id="results"></div>
  </div>

  <script>
    async function loadModels() {
      try {
        const r = await fetch('/models');
        const j = await r.json();
        const models = (j.models || []).sort();
        const sel = document.getElementById('model');
        sel.innerHTML = '';
        if (models.length === 0) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'No models found';
          sel.appendChild(opt);
        } else {
          for (const m of models) {
            const opt = document.createElement('option');
            opt.value = m;
            opt.textContent = m;
            sel.appendChild(opt);
          }
        }
      } catch (e) {
        console.error(e);
        document.getElementById('results').textContent = 'Error loading models: ' + e;
      }
    }

    function drawDetections(imgEl, detections) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const naturalW = imgEl.naturalWidth;
      const naturalH = imgEl.naturalHeight;
      canvas.width = naturalW;
      canvas.height = naturalH;
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.drawImage(imgEl, 0, 0, naturalW, naturalH);
      ctx.lineWidth = 2;
      ctx.font = '16px sans-serif';
      ctx.textBaseline = 'top';
      for (const d of detections || []) {
        const b = d.box || {};
        const x = b.x1 || 0; const y = b.y1 || 0;
        const w = Math.max(0, (b.x2||0) - x);
        const h = Math.max(0, (b.y2||0) - y);
        ctx.strokeStyle = '#00e676';
        ctx.fillStyle = 'rgba(0, 230, 118, 0.2)';
        ctx.strokeRect(x, y, w, h);
        ctx.fillRect(x, y, w, h);
        const label = (d.label != null ? d.label : d.class) + ' ' + (d.confidence != null ? d.confidence.toFixed(2) : '');
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        const tw = ctx.measureText(label).width + 8;
        const th = 20;
        ctx.fillRect(x, y, tw, th);
        ctx.fillStyle = '#fff';
        ctx.fillText(label, x + 4, y + 2);
      }
      canvas.style.display = 'block';
    }

    document.getElementById('file').addEventListener('change', (ev) => {
      const f = ev.target.files[0];
      const img = document.getElementById('preview');
      const canvas = document.getElementById('canvas');
      if (!f) { img.style.display='none'; canvas.style.display='none'; return; }
      const url = URL.createObjectURL(f);
      img.onload = () => {
        URL.revokeObjectURL(url);
        img.style.display='block';
        canvas.style.display='none';
      };
      img.src = url;
    });

    document.getElementById('runBtn').addEventListener('click', async () => {
      const model = document.getElementById('model').value;
      const fileInput = document.getElementById('file');
      const conf = document.getElementById('conf').value;
      const iou = document.getElementById('iou').value;
      const max_det = document.getElementById('max_det').value;
      const results = document.getElementById('results');
      const img = document.getElementById('preview');
      results.textContent = '';
      if (!model) { results.textContent = 'Please select a model.'; return; }
      if (!fileInput.files || fileInput.files.length === 0) { results.textContent = 'Please choose an image file.'; return; }
      const fd = new FormData();
      fd.append('file', fileInput.files[0]);
      fd.append('conf', conf);
      fd.append('iou', iou);
      fd.append('max_det', max_det);
      try {
        const resp = await fetch(`/v1/vision/custom/${encodeURIComponent(model)}`, { method: 'POST', body: fd });
        const txt = await resp.text();
        let json;
        try { json = JSON.parse(txt); } catch (e) { json = { raw: txt }; }
        results.textContent = JSON.stringify(json, null, 2);
        // The API returns detections in `predictions` (x_min, y_min, x_max, y_max, label, confidence)
        // Older code might use `detections` with { box: {x1,y1,x2,y2}, label, confidence }.
        let dets = null;
        if (json && Array.isArray(json.detections)) {
          dets = json.detections;
        } else if (json && Array.isArray(json.predictions)) {
          dets = json.predictions.map(p => ({
            box: { x1: p.x_min, y1: p.y_min, x2: p.x_max, y2: p.y_max },
            label: p.label,
            confidence: p.confidence
          }));
        }
        if (resp.ok && dets) {
          // Ensure image is loaded before drawing
          if (img.complete) {
            drawDetections(img, dets);
          } else {
            img.onload = () => drawDetections(img, dets);
          }
        }
      } catch (e) {
        results.textContent = 'Request failed: ' + e;
      }
    });

    loadModels();
  </script>
  </body>
  </html>
